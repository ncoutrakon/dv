#given a set of ideas generated by future_id() and a date to roll the most recent contract
#will get symbols from database and will stitch together a weighted bid-ask price
#will then stitch them together and adjust for a roll based on 28-days before contract expires
#and lastRoll date
rollFmonth <- function(id, days = 28, start = Sys.Date() - 90, lastRoll = NA, roll = T){
        
        getSymbols(id, from = start, use_identifier=NA)
        
        
        dat <- get(id[1])
                dat$midBA <- weightBA(dat)
        
        if(length(id) == 1){return(dat)}
        for(i in 2:(length(id))) {
                rtime <- index(dat[dim(dat)[1]]) 
                rtime <- as.Date(rtime, format = "%Y-%m-%d") - days
                if((i == length(id)) & !is.na(lastRoll)) {rtime <- as.Date(lastRoll) - 1}
                dat <- dat[paste0("/", rtime)]
                
                
                tmp <- get(id[i])
                        tmp$midBA <- weightBA(tmp)
                tmp <- tmp[paste0(rtime+1,"/")]
                
                if(roll) {rolld <- as.numeric(tmp[1,'midBA']) - as.numeric(dat[dim(dat)[1],'midBA']); dat$midBA <- dat$midBA + rolld}
                dat <- rbind(dat, tmp)       
        }

        dat
}



rollNmonth <- function(id, dates, start = Sys.Date() - 90, roll = T){
        
        getSymbols(id, from = start, use_identifier=NA)
        
        dat <- get(id[1])
                dat$midBA <- weightBA(dat)
        
        if(length(id) == 1){return(dat)}
        for(i in 2:(length(id))) {
                rtime <- as.Date(dates[i -1], format = "%Y-%m-%d") 
                dat <- dat[paste0("/", rtime)]
                
                
                tmp <- get(id[i])
                        tmp$midBA <- weightBA(tmp)
                tmp <- tmp[paste0(rtime+1,"/")]
                
                if(roll) {rolld <- as.numeric(tmp[1,'midBA']) - as.numeric(dat[dim(dat)[1],'midBA']); dat$midBA <- dat$midBA + rolld}
                dat <- rbind(dat, tmp)       
        }

        dat
}





#given a dataframe with two columns, price and indicator,
#will return a list of rolled prices and roll amounts at each point
#adjusts so last row in dataframe is the same and adjusts backward
rollPrices <- function(fly, rolls){
        cusips <- split(fly, rolls)
        
        num <- length(cusips)
        dat <- cusips[[num]]
        for(i in (length(cusips)-1):1) {
                rtime <- index(dat[dim(dat)[1]])
                
                dat <- dat[index(dat) <= rtime,]
                
                
                tmp <- cusips[[i]]
                
                
                roll <- as.numeric(tmp[1,'notion']) - as.numeric(dat[dim(dat)[1],'notion'])
                dat$notion <- dat$notion + roll
                dat <- rbind(dat, tmp)
                
        }
        
        
                dat <- xts(dat, order.by = index(dat))
                dat

}


# given an xts' 'zoo' object, will return an 'xts' 'zoo' object
#that has values for every time increment specified by freq = .
#
#freq = can take any value accepted by the seq.POSIxt() function
#creates a blank time-series, using first and last entry in tmp, and frequency defined by freq=


fillIn <- function(tmp, freq = "sec"){
        filled <- do.call.rbind(lapply(split(tmp, "days"), function(x) {
          if (NROW(x) > 100) {
            start.time <- as.POSIXct(paste(as.Date(start(x), tz= "America/Chicago"),
                                      "00:00:00"))
            end.time <- as.POSIXct(paste(as.Date(end(x), tz= "America/Chicago"),
                                      "23:59:59"))
            newts <- xts( , seq.POSIXt(start.time, end.time, freq))
            out <- na.locf(cbind(newts, x, all=TRUE), maxgap = Inf) 
            if (NROW(out) > 5) {
               out
            }
          }
        }))
        
        filled <- na.locf(filled, na.rm = T)
        filled
}





fillIn1 <- function(tmp, freq = "sec", start = "170000", except = c('Volume', 'Trade.Price')){
        start <- timeChar(start)
        diff <- 24*3600 - (as.numeric(start$hr)*3600+as.numeric(start$min)*60+as.numeric(start$sec))
        pat <- paste(paste0("^", except), collapse = "|")

        filled <- do.call.rbind(lapply(split(tmp, "days"), function(x) {
          if (NROW(x) > 100) {
                index(x) <- index(x) + diff
            start.time <- as.POSIXct(paste(as.Date(start(x), tz= "America/Chicago"),
                                      "00:00:00"))
            end.time <- as.POSIXct(paste(as.Date(end(x), tz= "America/Chicago"),
                                      "23:59:59"))
            newts <- xts( , seq.POSIXt(start.time, end.time, freq))
            out <- na.locf(cbind(newts, x[, -grep(pat, colnames(x))], all=TRUE), maxgap = Inf)
            exceptCol <- cbind(newts, x[, grep(pat, colnames(x))], all = T)
            out <- cbind(out, exceptCol, all = T)
                index(out) <- index(out) - diff
            if (NROW(out) > 5) {
               out
            }
          }
        }))
        
        
        #filled <- filled[rowSums(is.na(filled)) != NCOL(filled),]
        filled
}






#for netchange, needs a column titled 'notion'
#given any 'xts' 'zoo' object, will create trade time columns for week-minute, trade minute, trade second, and trade day
#will also add a column to include prior days settle price and subsequently, the netchagne from said price if there is a 'notion' column
# removes first days worth of data
#returns 'xts' 'zoo' object
#take 'xts' 'zoo', market start time in minutes, end time in minutes, and settle time in minutes
#will not include end time of market

getNchange <- function(dat, startTday = "170000", endTday = "160000", setTime = "140000"){
        
        sTime <- timeChar(startTday)
        sHr <- as.numeric(sTime$hr); sMin <- as.numeric(sTime$min); sSec <- as.numeric(sTime$sec)
        startTday <- sHr*60*60 + sMin*60 + sSec
        
        
        eTime <- timeChar(endTday)
        eHr <- as.numeric(eTime$hr); eMin <- as.numeric(eTime$min); eSec <- as.numeric(eTime$sec)
        endTday <- eHr*60*60 + eMin*60 + eSec
        
        setTime <- timeChar(setTime)
        setHr <- as.numeric(setTime$hr); setMin <- as.numeric(setTime$min); setSec <- as.numeric(setTime$sec)
        setTime <- setHr*60*60 + setMin*60 + setSec        
                
                
        #adds coluns to keep track of times throughout the week
        dat$wmin <- .indexwday(dat)*24*60 + .indexhour(dat)*60 +.indexmin(dat)
        dat$trmin <- .indexhour(dat)*60 + .indexmin(dat)
        dat$trsec <- .indexhour(dat)*3600 + .indexmin(dat)*60 + .indexsec(dat)
        
        
        #only keep data sunday open thru friday close
        dat <- dat[(dat$wmin >= startTday / 60) & (dat$wmin <= (5*24*60 + endTday/60)),]
        
        
        #trading days begin after the close of last trading day
        dat$trday <- c(0, 1*(dat$trsec == endTday)[1:(dim(dat)[1] - 1)])
        dat$trday <- cumsum(dat$trday)
        
        #calculate settles and netchagne
        if(any(names(dat) %in% 'notion')){
                dat$settle <- apply(dat[,c('trsec', 'notion')], 1, function(x) ifelse(x['trsec'] == setTime, x['notion'], NA))
                dat$settle <- na.locf(dat$settle, na.rm = F)
                dat$netchange <- dat$notion - dat$settle
        }
        
        #only keep data for each trading day from startTday to endTday
        start <- format(as.POSIXct('0001-01-01 00:00:00') + startTday + 1, "%H:%M:%S")
        end <- format(as.POSIXct('0001-01-01 00:00:00') + endTday, "%H:%M:%S")
        
        splice <- paste0("T", start,"/T",end)
        dat <- dat[splice]
        
        dat <- dat[dat$trday != 0,]
        dat

}



##given output df of getNchange(), i.e. data with a trday column, will return cleaned data that only contains days
#with complete data. returns the size of each day as well as how many days there ar

getNorm <- function(dat){
        dims <- table(dat$trday)
                dim <- as.numeric(names(sort(table(dims), decreasing= T))[1])
        
        keep <- as.numeric(names(dims[dims == dim]))
        nDays <- length(keep)
        
        print(paste(length(dims),"days given"))
        print(paste("Most common size:", dim))
        print(paste("Keeping:", nDays,". Discarding:", length(dims) - nDays))
        
        dat <- dat[dat$trday %in% keep, ]
        
        list(dat = dat, dim = dim, nDays = nDays)
        
}



##given an output of getNchange(), i.e. a data frame with a trday column, will return a list of dataframes
#where each element includes all of the entries for a particular "bucket" of the day.
#for example, if buk = 60, we will use 60min buckets to group the data for the different days
##buk is in minutes so it is important to check that the number of entries per day is divisible by buk*60
getBuks <- function(dat, dim, nDays, buk = 5){
        
        buk <- buk*60
        numBux <- dim/buk
        
        factr <- rep(rep(1:numBux, each = buk), nDays)
        buckets <- split(dat, factr)
        
        buckets

}



### given a string of time, "HHMMNN" or "HMMNN" will return the hour, minute, and second component
timeChar <- function(timeString){
        sec <- substr(timeString, nchar(timeString) - 1, nchar(timeString))
        min <- substr(timeString, nchar(timeString) - 3, nchar(timeString) - 2)
        hr <- substr(timeString,1,nchar(timeString)-4)
        
        list(hr = hr, min = min, sec = sec)
}

weightBA <- function(dat){
        (1/(dat$Bid.Size + dat$Ask.Size))*(dat$Bid.Price*dat$Bid.Size + dat$Ask.Price*dat$Ask.Size)
}

